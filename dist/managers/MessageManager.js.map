{"version":3,"file":"MessageManager.js","sourceRoot":"","sources":["../../src/managers/MessageManager.ts"],"names":[],"mappings":"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","sourcesContent":["import { Message as RawMessage } from 'revolt-api/types/Channels'\nimport { User as RawUser } from 'revolt-api/types/Users'\nimport { BaseManager } from '.'\nimport { TypeError } from '../errors'\nimport { Channel, Message, User } from '../structures'\nimport { Collection, UUID } from '../util'\n\nexport type MessageResolvable = Message | RawMessage | string\n\nexport interface EditMessageOptions {\n    content?: string\n}\n\nexport interface MessageOptions {\n    content: string\n    replies?: unknown[]\n    attachments?: string[]\n}\n\nexport interface SerachMessageQuery {\n    query: string\n    limit?: number\n    before?: string\n    after?: string\n    sort?: 'Relevance' | 'Latest' | 'Oldest'\n    include_users?: boolean\n}\n\nexport class MessageManager extends BaseManager<string, Message, RawMessage> {\n    holds = Message\n    client = this.channel.client\n    constructor(public channel: Channel) {\n        super()\n    }\n\n    private async _fetchId(messageId: string) {\n        const data = await this.client.api.get(`/channels/${this.channel.id}/messages/${messageId}`)\n        return this._add(data)\n    }\n\n    private async _fetchMany(withUsers = true) {\n        const { messages } = await this.client.api.get(`/channels/${this.channel.id}/messages?include_users=${withUsers}`)\n        return (messages as RawMessage[]).reduce((coll, cur) => {\n            const msg = this._add(cur)\n            coll.set(msg.id, msg)\n            return coll\n        }, new Collection<string, Message>())\n    }\n\n    async send(_options: MessageOptions | string): Promise<Message> {\n        const { content, replies, attachments }: MessageOptions =\n            typeof _options === 'object'\n                ? { ..._options }\n                : {\n                      content: _options\n                  }\n\n        const data = await this.client.api.post(`/channels/${this.channel.id}/messages`, {\n            body: {\n                content,\n                nonce: UUID.generate(),\n                replies,\n                attachments\n            }\n        })\n\n        return this._add(data)\n    }\n\n    async ack(message: MessageResolvable): Promise<void> {\n        const messageId = this.resolveId(message)\n        if (!messageId) throw new TypeError('INVALID_TYPE', 'message', 'MessageResolvable')\n        await this.client.api.put(`/channels/${this.channel.id}/ack/${messageId}`)\n    }\n\n    async delete(message: MessageResolvable): Promise<void> {\n        const messageId = this.resolveId(message)\n        if (!messageId) throw new TypeError('INVALID_TYPE', 'message', 'MessageResolvable')\n        await this.client.api.delete(`/channels/${this.channel.id}/messages/${messageId}`)\n    }\n\n    async edit(message: MessageResolvable, options: EditMessageOptions): Promise<void> {\n        const messageId = this.resolveId(message)\n        if (!messageId) throw new TypeError('INVALID_TYPE', 'message', 'MessageResolvable')\n        await this.client.api.patch(`/channels/${this.channel.id}/messages/${messageId}`, {\n            body: options\n        })\n    }\n\n    async search(query: SerachMessageQuery & { include_users: true }): Promise<{\n        users: Collection<string, User>\n        messages: Collection<string, Message>\n    }>\n    async search(query: SerachMessageQuery & { include_users?: false }): Promise<Collection<string, Message>>\n    async search(query: SerachMessageQuery): Promise<\n        | Collection<string, Message>\n        | {\n              users: Collection<string, User>\n              messages: Collection<string, Message>\n          }\n    > {\n        const response = await this.client.api.post(`/channels/${this.channel.id}/search`, {\n            body: query\n        })\n\n        if (query.include_users) {\n            const users = (response.users as RawUser[]).reduce((coll, cur) => {\n                const user = this.client.users._add(cur)\n                coll.set(user.id, user)\n                return coll\n            }, new Collection<string, User>())\n\n            const messages = (response.messages as RawMessage[]).reduce((coll, cur) => {\n                const msg = this._add(cur)\n                coll.set(msg.id, msg)\n                return coll\n            }, new Collection<string, Message>())\n\n            return {\n                messages,\n                users\n            }\n        } else {\n            return (response as RawMessage[]).reduce((coll, cur) => {\n                const msg = this._add(cur)\n                coll.set(msg.id, msg)\n                return coll\n            }, new Collection<string, Message>())\n        }\n    }\n\n    fetch(messageId: string): Promise<Message>\n    fetch(options: { includeUsers: true }): Promise<{\n        users: Collection<string, User>\n        messages: Collection<string, Message>\n    }>\n    fetch(options?: { includeUsers?: false }): Promise<Collection<string, Message>>\n    fetch(options?: string | { includeUsers?: boolean }): Promise<\n        | Collection<string, Message>\n        | {\n              users: Collection<string, User>\n              messages: Collection<string, Message>\n          }\n        | Message\n    > {\n        return typeof options === 'string' ? this._fetchId(options) : this._fetchMany(options?.['includeUsers'])\n    }\n}\n"]}