{"version":3,"file":"BitField.js","sourceRoot":"","sources":["../../src/util/BitField.ts"],"names":[],"mappings":"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","sourcesContent":["import { RangeError } from '../errors'\n\nconst DEFAULT_BIT = 0\n\nexport type BitFieldResolvable = BitField | number | string | BitFieldResolvable[]\n\nexport class BitField {\n    static FLAGS: Record<string, number> = {}\n    bitfield = 0\n    constructor(bits: BitFieldResolvable = DEFAULT_BIT) {\n        this.bitfield = this.self.resolve(bits)\n    }\n\n    get self(): {\n        FLAGS: Record<string, number>\n        resolve(bit: BitFieldResolvable): number\n        new (bits?: BitFieldResolvable): BitField\n    } {\n        return this.constructor as unknown as {\n            FLAGS: Record<string, number>\n            resolve(bit: BitFieldResolvable): number\n            new (bits?: BitFieldResolvable): BitField\n        }\n    }\n\n    any(bit: BitFieldResolvable): boolean {\n        bit = this.self.resolve(bit)\n        return (this.bitfield & bit) !== DEFAULT_BIT\n    }\n\n    has(bit: BitFieldResolvable): boolean {\n        bit = this.self.resolve(bit)\n        return (this.bitfield & bit) === bit\n    }\n\n    toArray(): string[] {\n        return Object.keys(this.self.FLAGS).filter(bit => this.has(bit))\n    }\n\n    add(...bits: BitFieldResolvable[]): this {\n        let total = 0\n\n        for (const bit of bits) {\n            total |= this.self.resolve(bit)\n        }\n\n        if (Object.isFrozen(this)) return new this.self(this.bitfield | total) as this\n\n        this.bitfield |= total\n\n        return this\n    }\n\n    remove(...bits: BitFieldResolvable[]): this {\n        let total = 0\n\n        for (const bit of bits) {\n            total |= this.self.resolve(bit)\n        }\n\n        if (Object.isFrozen(this)) return new this.self(this.bitfield & ~total) as this\n\n        this.bitfield &= ~total\n\n        return this\n    }\n\n    freeze(): Readonly<this> {\n        return Object.freeze(this)\n    }\n\n    valueOf(): number {\n        return this.bitfield\n    }\n\n    serialize(): Record<string, boolean> {\n        const serialized: Record<string, boolean> = {}\n        for (const [flag, bit] of Object.entries(this.self.FLAGS)) serialized[flag] = this.has(bit)\n        return serialized\n    }\n\n    *[Symbol.iterator](): Iterable<string> {\n        yield* this.toArray()\n    }\n\n    static resolve(bit: BitFieldResolvable): number {\n        if (bit instanceof BitField) return bit.bitfield\n        if (typeof bit === 'number' && bit >= DEFAULT_BIT) return bit\n        if (Array.isArray(bit)) return bit.map(p => this.resolve(p)).reduce((prev, p) => prev | p, DEFAULT_BIT)\n        if (typeof this.FLAGS[bit] !== 'undefined') return this.FLAGS[bit]\n        throw new RangeError('BITFIELD_INVALID', bit)\n    }\n}\n"]}